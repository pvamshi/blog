<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Project building using node - Frontend Development
    </title>
    <link rel="alternate" href="http://vamshi-krishna.com/angular/feed.xml" type="application/rss+xml" title="console.log(me); // ['Javascript', 'Angular', 'React']">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Project building using node</h1>
        <p class="author">Written by <span class="author"><a href="mailto:pvamshi@gmail.com">Vamshi Krishna`</a></span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><h3 id="introduction">Introduction</h3>
<p>The de facto way of watching and building a <span class="caps">UI</span> project is by using either of grunt, gulp or rarely npm. In this blog we will see how it can be done using node<span class="widont">&nbsp;</span>alone.  </p>
<h3 id="general-idea">General Idea</h3>
<p>We will be using node apps to perform these actions. Depending on grunt ( I will be talking mostly about grunt as that is what being used in our project) might look simpler but writing our own script is easier to debug, maintain and scale over long run. The tasks we perform are going to be watch filesystem for changes and perform an action when there is a<span class="widont">&nbsp;</span>change. </p>
<h3 id="start">Start</h3>
<p>Lets start the project from scratch. We can use existing project as well. The structure is going to be like<span class="widont">&nbsp;</span>: </p>
<pre><code>└── test
    ├── build
    │   ├── index.html
    │   ├── site.css
    │   └── site.js
    ├── node_modules
    ├── package.json
    ├── src
    │   ├── css
    │   ├── index.html
    │   └── js
    └── temp</code></pre><p><code>src</code> is where the source code is going to saved. <code>build</code> is for final build where all the javascript is loaded to single javascript file and all the css( sass comipled) in a single css.  We will be having all our javascript in <span class="caps">ES6</span> ( can be typescript or coffeescript or other format too )  .
<code>temp</code> folder is where we store the compiled files ( js or<span class="widont">&nbsp;</span>css). </p>
<p>The steps are as follows<span class="widont">&nbsp;</span>:</p>
<pre><code class="language-shell"><span class="meta">$</span><span class="bash"> mkdir <span class="built_in">test</span> </span>
<span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span>
<span class="meta">$</span><span class="bash"> npm init</span>
<span class="meta">$</span><span class="bash"> mkdir src build temp src/js src/css</span>
<span class="meta">#</span><span class="bash"> touch src/index.html</span>
<span class="meta">#</span><span class="bash"></span></code></pre>
<p>When we run <code>npm init</code> the <code>package.json</code> file gets created after asking few basic questions. 
With this we have the basic file system<span class="widont">&nbsp;</span>ready.</p>
<h3 id="watch">Watch</h3>
<p>To watch the file system for changes we use the package called <a href="https://github.com/paulmillr/chokidar">Chokidar</a>.</p>
<pre><code class="language-shell"><span class="meta">$</span><span class="bash"> npm install --save chokidar</span></code></pre>
<p>This adds a dependency in <code>package.json</code> along with installing it into <code>node_modules</code>. 
Create a build script to run our app. Lets call it <code>index.js</code> . </p>
<pre><code class="language-shell"><span class="meta">$</span><span class="bash">touch index.js</span></code></pre>
<p>We can start using chokidar to watch<span class="widont">&nbsp;</span>files. </p>
<pre><code class="language-javascript"><span class="comment">// index.js</span>
<span class="keyword">const</span> chokidar = <span class="built_in">require</span>(<span class="string">'chokidar'</span>);

chokidar.watch(<span class="string">'./src/js/**/*.js'</span>)
  .on(<span class="string">'add'</span>,(path) =&gt; {
    <span class="built_in">console</span>.log(<span class="string">'file added to watch '</span>+path);
    })
  .on(<span class="string">'change'</span>, (path)=&gt; {
    <span class="built_in">console</span>.log(<span class="string">'file changed '</span>+path);
  });</code></pre>
<p>With this tiny code we have established a watcher on our file system. <code>**/*.js</code> matches all the files which end with .js in the particular file system ( /src/js in our case) . As we will not be using any other function of chokidar we can simplify the require statement a little<span class="widont">&nbsp;</span>: </p>
<pre><code class="language-javascript"><span class="keyword">const</span> watch = <span class="built_in">require</span>(<span class="string">'chokidar'</span>).watch;

watch(<span class="string">'./src/js/**/*.js'</span>)
  .on(<span class="string">'add'</span>,(path) =&gt; {
  ...</code></pre>
<h3 id="read-write-to-files">Read Write to<span class="widont">&nbsp;</span>files</h3>
<p>We can use default node apps to read and write to file system. But I found <a href="https://github.com/shelljs/shelljs">shelljs</a> much easier to work with. With shelljs, the code is going to look exactly like shell but with functions instead of commands. Shelljs gives almost all important shell commands like cat, mkdir, echo etc ., 
Two ways to use shelljs , if we import shelljs/global we can directly access all the shell command ( cat(file)) otherwise we need to call it with a variable (shell.cat(file)). I liked the global format so will go with<span class="widont">&nbsp;</span>it. </p>
<pre><code>$ npm install shelljs --save</code></pre><p>update the index.js</p>
<pre><code class="language-js"><span class="comment">//index.js</span>
<span class="built_in">require</span>(<span class="string">'shelljs/global'</span>)
echo(<span class="string">'echo test'</span>);</code></pre>
<p>This should print the text to console . This is just to test if its working<span class="widont">&nbsp;</span>fine. </p>
<h3 id="transpiler-for-es6">Transpiler for <span class="caps">ES6</span></h3>
<p>Assuming we will be writing our web app in <span class="caps">ES6</span>, we need to transpile the code to <span class="caps">ES5</span>. Lets use <a href="/articles/node-build/babeljs.io">babeljs</a> for this<span class="widont">&nbsp;</span>task. </p>
<pre><code>$ npm install --save babel babel-preset-es2015</code></pre><p>Lets convert some javascript from <span class="caps">ES2015</span> to javscript<span class="widont">&nbsp;</span>5</p>
<pre><code class="language-js"><span class="comment">//index.js</span>
<span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);
<span class="keyword">const</span> presets = {
  <span class="attr">presets</span>: [ <span class="string">'es2015'</span>]
};
<span class="function"><span class="keyword">function</span> <span class="title">transpileToEs5</span>(<span class="params">code</span>)</span>{
  <span class="keyword">return</span> babel.transform(code, presets);
}
echo(transpileToEs5(<span class="string">`let a = 5;`</span>));</code></pre>
<p>This should output <code>var a = 5;</code> to the<span class="widont">&nbsp;</span>output. </p>
<h3 id="final-code">Final code</h3>
<p>Lets combine all these to final<span class="widont">&nbsp;</span>code. </p>
<pre><code class="language-js"><span class="comment">//index.js</span>

<span class="keyword">const</span> watch = <span class="built_in">require</span>(<span class="string">'chokidar'</span>).watch;
<span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);
<span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);
<span class="keyword">const</span> presets = {
  <span class="attr">presets</span>: [ <span class="string">'es2015'</span>]
};

watch(<span class="string">'./src/js/**/*.js'</span>)
  .on(<span class="string">'add'</span>, (path) =&gt; {
    <span class="built_in">console</span>.log(<span class="string">'file added to watch '</span>+path);
    <span class="keyword">let</span> code = cat(path);
    <span class="keyword">let</span> es5Code = transpileToEs5(code);
    <span class="keyword">let</span> destinyFile = <span class="string">'./temp'</span>+path;
    mkdir(<span class="string">'-p'</span>, destinyFile);
    es5Code.to(destinyFile);
  })
  .on(<span class="string">'change'</span>, (path)=&gt; {
    <span class="built_in">console</span>.log(<span class="string">'file changed '</span>+path);
    <span class="keyword">let</span> code = cat(path);
    <span class="keyword">let</span> es5Code = transpileToEs5(code);
    <span class="keyword">let</span> destinyFile = <span class="string">'./temp'</span>+path;
    es5Code.to(destinyFile);
  });

<span class="string">''</span>.to(<span class="string">'./build/site.js'</span>); <span class="comment">//empty the file everytime the build is run</span>

watch(<span class="string">'./temp/**/*.js'</span>)
  .on(<span class="string">'add'</span>, (path) =&gt; {
    cat(path).toEnd(<span class="string">'./build/site.js'</span>); <span class="comment">//append to the end of the file </span>
  })
  .on(<span class="string">'change'</span>, () =&gt; {
    cat(<span class="string">'./temp/**/*.js'</span>).to(<span class="string">'./build/site.js'</span>); <span class="comment">//override whole file</span>
  });

<span class="function"><span class="keyword">function</span> <span class="title">transpileToEs5</span>(<span class="params">code</span>)</span>{
  <span class="keyword">return</span> babel.transform(code, presets);
}</code></pre>
<p>Here we are watching on <code>src</code> and <code>temp</code>. Whevever there is a change in src, we compile and copy to temp. Whenever there is change or new file added to temp directory, we copy whole of temp again to site.js. 
This is very basic code which can be further optimized a lot but left as is to make it easy to understand. 
We can add more watchers and more logic in each watch. 
That is it. If we write code in our src , it automatically compiles and updates<span class="widont">&nbsp;</span>site.js. </p>
<h3 id="conclusion">Conclusion</h3>
<p>As we can see its very easy to write our own build code. It is very extensible, when we need to add more features , we just add new dependency and add another function in our code. Here are the advantages of using this instead of grunt or<span class="widont">&nbsp;</span>gulp: </p>
<ul>
<li>Add or remove features<span class="widont">&nbsp;</span>easily</li>
<li>Add customized features easily as its plain javascript<span class="widont">&nbsp;</span>code</li>
<li>If we are dealing with micro services or multiple projects, We can add a config file and decide which ones to enable and disable for each project. All the projects can use the same script and its easy to impose rules or overwrite<span class="widont">&nbsp;</span>rules</li>
<li>Convert this to a module and share across<span class="widont">&nbsp;</span>teams.</li>
</ul>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">&laquo; All blogs</a></div>
        <section class="about"><p>I am a frontend developer working for <a href="http://syncron.com/">Syncron</a> 
located at Bengaluru. I blog to record and share technical learnings in day today life. </p>

        </section>
        <section class="copy">
          <p>&copy; 2019 Vamshi Krishna &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a></p>
        </section>
      </div>
    </footer>
  </body>
</html>